<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quickstart Tutorial — openrappter</title>
  <meta name="description" content="From zero to a working openrappter agent in minutes. Follow along in TypeScript or Python.">
  <meta property="og:title" content="Quickstart Tutorial — openrappter">
  <meta property="og:description" content="From zero to a working agent in minutes. Follow along in TypeScript or Python.">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="./styles.css">
</head>
<body>

  <!-- Nav -->
  <nav>
    <div class="nav-container">
      <a href="./" class="logo">openrappter <span class="logo-badge">v1.4.1</span></a>
      <button class="mobile-menu-btn">&#9776;</button>
      <div class="nav-links">
        <a href="./docs.html">Docs</a>
        <a href="./architecture.html">Architecture</a>
        <a href="./tutorial.html">Tutorial</a>
        <a href="./changelog.html">Changelog</a>
      </div>
      <div class="nav-cta">
        <a href="https://github.com/kody-w/openrappter" class="btn btn-ghost">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"/></svg>
          GitHub
        </a>
      </div>
    </div>
  </nav>

  <!-- Hero -->
  <section class="hero">
    <div class="hero-bg"></div>
    <h1><span class="highlight">Quickstart</span> Tutorial</h1>
    <p class="hero-subtitle">From zero to a working agent in minutes. Follow along in TypeScript or Python.</p>
  </section>

  <!-- Main layout -->
  <div style="display:flex;justify-content:center;gap:3rem;max-width:1100px;margin:0 auto;padding:0 2rem 6rem;">

    <!-- Progress sidebar -->
    <div class="progress-nav">
      <ol>
        <li><a href="#step-1">1. Install</a></li>
        <li><a href="#step-2">2. Verify</a></li>
        <li><a href="#step-3">3. CLI Basics</a></li>
        <li><a href="#step-4">4. Memory</a></li>
        <li><a href="#step-5">5. Create Agent</a></li>
        <li><a href="#step-6">6. Test It</a></li>
        <li><a href="#step-7">7. Data Sloshing</a></li>
        <li><a href="#step-8">8. Chain Agents</a></li>
        <li><a href="#step-9">9. Multi-Agent</a></li>
      </ol>
    </div>

    <!-- Content -->
    <main style="max-width:800px;width:100%;">

      <!-- Step 1: Install -->
      <div class="step" id="step-1">
        <div class="step-number">1</div>
        <h2>Install</h2>
        <p>There are three ways to get openrappter running. Pick whichever fits your workflow.</p>

        <p><strong>Option A — one-line installer (recommended):</strong></p>
        <pre><code><span class="cmd">curl -fsSL https://kody-w.github.io/openrappter/install.sh | bash</span></code></pre>
        <p>The script detects your platform, clones the repo, installs dependencies, builds the TypeScript runtime, and adds <code>openrappter</code> to your PATH.</p>

        <p><strong>Option B — manual clone:</strong></p>
        <pre><code><span class="comment"># TypeScript runtime</span>
<span class="cmd">git clone https://github.com/kody-w/openrappter.git</span>
<span class="cmd">cd openrappter/typescript</span>
<span class="cmd">npm install</span>
<span class="cmd">npm run build</span>

<span class="comment"># Python runtime (optional, mirrors TypeScript)</span>
<span class="cmd">cd ../python</span>
<span class="cmd">pip install -e .</span></code></pre>

        <p><strong>Option C — teach your existing agent:</strong> If you already have an AI assistant, paste the <a href="https://raw.githubusercontent.com/kody-w/openrappter/main/skills.md">skills.md</a> link into your conversation and ask it to set up openrappter for you. It can handle the full install and scaffold new agents.</p>

        <div class="info-box">
          <strong>Prerequisites:</strong> Node.js 18+ is required for the TypeScript runtime. Python 3.10+ is required for the Python runtime. Both runtimes implement the same agent contract and are interchangeable.
        </div>
      </div>

      <!-- Step 2: Verify -->
      <div class="step" id="step-2">
        <div class="step-number">2</div>
        <h2>Verify</h2>
        <p>Confirm the installation is healthy before writing any code.</p>

        <pre><code><span class="comment"># Check version — should print v1.4.1</span>
<span class="cmd">openrappter --version</span></code></pre>

        <div class="terminal">
          <div class="terminal-header">
            <span class="terminal-dot red"></span>
            <span class="terminal-dot yellow"></span>
            <span class="terminal-dot green"></span>
            <span class="terminal-title">openrappter --version</span>
          </div>
          <div class="terminal-body">
            <div class="terminal-line">
              <span class="terminal-prompt">$</span>
              <span class="terminal-command">openrappter --version</span>
            </div>
            <div class="terminal-output">openrappter v1.4.1</div>
          </div>
        </div>

        <pre><code><span class="comment"># List all auto-discovered agents</span>
<span class="cmd">openrappter --list-agents</span></code></pre>

        <div class="terminal">
          <div class="terminal-header">
            <span class="terminal-dot red"></span>
            <span class="terminal-dot yellow"></span>
            <span class="terminal-dot green"></span>
            <span class="terminal-title">openrappter --list-agents</span>
          </div>
          <div class="terminal-body">
            <div class="terminal-line">
              <span class="terminal-prompt">$</span>
              <span class="terminal-command">openrappter --list-agents</span>
            </div>
            <div class="terminal-output">Available agents (3):</div>
            <div class="terminal-output">  BasicAgent     — Abstract base with data sloshing</div>
            <div class="terminal-output">  ShellAgent     — Shell commands, file read/write/list</div>
            <div class="terminal-output">  MemoryAgent    — Memory storage and retrieval</div>
          </div>
        </div>

        <p>If you see agents listed, the runtime discovered your <code>src/agents/</code> (TypeScript) or <code>python/openrappter/agents/</code> (Python) directory successfully. Any custom agents you add there will appear here automatically.</p>
      </div>

      <!-- Step 3: CLI Basics -->
      <div class="step" id="step-3">
        <div class="step-number">3</div>
        <h2>CLI Basics</h2>
        <p>openrappter has three primary usage patterns from the command line.</p>

        <p><strong>Interactive REPL mode</strong> — drop into a persistent session where the agent remembers context across messages:</p>
        <pre><code><span class="cmd">openrappter</span></code></pre>

        <p><strong>Single task mode</strong> — run one task and exit, useful for scripting:</p>
        <pre><code><span class="cmd">openrappter --task "list files in current directory"</span></code></pre>

        <p><strong>Specify an agent directly</strong> — bypass the router and run a named agent:</p>
        <pre><code><span class="cmd">openrappter --agent shell "what's in my home directory?"</span>
<span class="cmd">openrappter --exec ShellAgent "read package.json"</span></code></pre>

        <div class="terminal">
          <div class="terminal-header">
            <span class="terminal-dot red"></span>
            <span class="terminal-dot yellow"></span>
            <span class="terminal-dot green"></span>
            <span class="terminal-title">single task example</span>
          </div>
          <div class="terminal-body">
            <div class="terminal-line">
              <span class="terminal-prompt">$</span>
              <span class="terminal-command">openrappter --task "list files in current directory"</span>
            </div>
            <div class="terminal-output">Executing ShellAgent...</div>
            <div class="terminal-output">README.md  package.json  src/  dist/  node_modules/</div>
            <div class="terminal-success">Done.</div>
          </div>
        </div>

        <p>Other useful flags: <code>--status</code> shows loaded agents and runtime health, <code>--version</code> prints the version, and <code>--help</code> lists all available options.</p>
      </div>

      <!-- Step 4: Memory -->
      <div class="step" id="step-4">
        <div class="step-number">4</div>
        <h2>Memory</h2>
        <p>openrappter has first-class persistent memory that survives across sessions. Anything you store is written locally and recalled automatically in future queries.</p>

        <p><strong>Store a fact:</strong></p>
        <pre><code><span class="cmd">openrappter "remember that I prefer dark mode"</span></code></pre>

        <div class="terminal">
          <div class="terminal-header">
            <span class="terminal-dot red"></span>
            <span class="terminal-dot yellow"></span>
            <span class="terminal-dot green"></span>
            <span class="terminal-title">storing a memory</span>
          </div>
          <div class="terminal-body">
            <div class="terminal-line">
              <span class="terminal-prompt">$</span>
              <span class="terminal-command">openrappter "remember that I prefer dark mode"</span>
            </div>
            <div class="terminal-success">Got it. I'll remember: "I prefer dark mode" (id: a3f1c9)</div>
          </div>
        </div>

        <p><strong>Recall facts:</strong></p>
        <pre><code><span class="cmd">openrappter "what do you know about my preferences?"</span></code></pre>

        <div class="terminal">
          <div class="terminal-header">
            <span class="terminal-dot red"></span>
            <span class="terminal-dot yellow"></span>
            <span class="terminal-dot green"></span>
            <span class="terminal-title">recalling memory</span>
          </div>
          <div class="terminal-body">
            <div class="terminal-line">
              <span class="terminal-prompt">$</span>
              <span class="terminal-command">openrappter "what do you know about my preferences?"</span>
            </div>
            <div class="terminal-output">Here's what I remember about your preferences:</div>
            <div class="terminal-output">  - I prefer dark mode  (stored 2 minutes ago)</div>
          </div>
        </div>

        <p>Memory entries are stored at <code>~/.openrappter/memory.json</code> as structured JSON. Each entry contains an ID, content, tags, created timestamp, and an access counter that helps the agent prioritize frequently recalled facts.</p>

        <div class="info-box">
          <strong>Local-first:</strong> All memory is stored on your machine. No data leaves your system. You can inspect, back up, or wipe the file at any time with <code>cat ~/.openrappter/memory.json</code> or <code>rm ~/.openrappter/memory.json</code>.
        </div>
      </div>

      <!-- Step 5: Create Agent -->
      <div class="step" id="step-5">
        <div class="step-number">5</div>
        <h2>Create a Custom Agent</h2>
        <p>Every agent in openrappter follows the single-file pattern: one file, one agent. The metadata contract, documentation, and implementation all live together using native language constructs — no YAML, no config files, no magic parsing.</p>

        <p>Create a <strong>GreeterAgent</strong> that returns a time-aware greeting and passes data downstream via <code>data_slush</code>.</p>

        <div class="code-tabs">
          <div class="code-tabs-header">
            <button class="code-tab-btn active" onclick="switchTab(this, 'ts-step5')">TypeScript</button>
            <button class="code-tab-btn" onclick="switchTab(this, 'py-step5')">Python</button>
          </div>
          <div class="code-tab-content active" id="ts-step5">
<pre><code><span class="comment">// typescript/src/agents/GreeterAgent.ts</span>
<span class="kw">import</span> { BasicAgent } <span class="kw">from</span> <span class="str">'./BasicAgent.js'</span>;
<span class="kw">import type</span> { AgentMetadata } <span class="kw">from</span> <span class="str">'./types.js'</span>;

<span class="kw">export class</span> GreeterAgent <span class="kw">extends</span> BasicAgent {
  <span class="fn">constructor</span>() {
    <span class="kw">const</span> metadata: AgentMetadata = {
      name: <span class="str">'GreeterAgent'</span>,
      description: <span class="str">'Greets users by name with a fun fact'</span>,
      parameters: {
        type: <span class="str">'object'</span>,
        properties: {
          name: { type: <span class="str">'string'</span>, description: <span class="str">'Name to greet'</span> }
        },
        required: [<span class="str">'name'</span>]
      }
    };
    <span class="fn">super</span>(<span class="str">'GreeterAgent'</span>, metadata);
  }

  <span class="kw">async</span> <span class="fn">perform</span>(kwargs: Record&lt;string, unknown&gt;) {
    <span class="kw">const</span> name = kwargs.name <span class="kw">as</span> string;
    <span class="kw">const</span> hour = <span class="kw">new</span> <span class="fn">Date</span>().getHours();
    <span class="kw">const</span> greeting = hour &lt; 12 ? <span class="str">'Good morning'</span> : hour &lt; 18 ? <span class="str">'Good afternoon'</span> : <span class="str">'Good evening'</span>;
    <span class="kw">return</span> {
      message: <span class="str">`${greeting}, ${name}!`</span>,
      data_slush: { greeted_user: name, time_of_day: greeting }
    };
  }
}</code></pre>
          </div>
          <div class="code-tab-content" id="py-step5">
<pre><code><span class="comment"># python/openrappter/agents/greeter_agent.py</span>
<span class="kw">from</span> openrappter.agents.basic_agent <span class="kw">import</span> BasicAgent
<span class="kw">from</span> datetime <span class="kw">import</span> datetime

<span class="kw">class</span> GreeterAgent(BasicAgent):
    <span class="kw">def</span> <span class="fn">__init__</span>(self):
        self.name = <span class="str">'GreeterAgent'</span>
        self.metadata = {
            <span class="str">"name"</span>: self.name,
            <span class="str">"description"</span>: <span class="str">"Greets users by name with a fun fact"</span>,
            <span class="str">"parameters"</span>: {
                <span class="str">"type"</span>: <span class="str">"object"</span>,
                <span class="str">"properties"</span>: {
                    <span class="str">"name"</span>: {<span class="str">"type"</span>: <span class="str">"string"</span>, <span class="str">"description"</span>: <span class="str">"Name to greet"</span>}
                },
                <span class="str">"required"</span>: [<span class="str">"name"</span>]
            }
        }
        <span class="fn">super</span>().__init__(name=self.name, metadata=self.metadata)

    <span class="kw">def</span> <span class="fn">perform</span>(self, **kwargs):
        name = kwargs.<span class="fn">get</span>(<span class="str">'name'</span>, <span class="str">'World'</span>)
        hour = datetime.<span class="fn">now</span>().hour
        greeting = <span class="str">'Good morning'</span> <span class="kw">if</span> hour &lt; 12 <span class="kw">else</span> <span class="str">'Good afternoon'</span> <span class="kw">if</span> hour &lt; 18 <span class="kw">else</span> <span class="str">'Good evening'</span>
        <span class="kw">return</span> {
            <span class="str">"message"</span>: <span class="kw">f</span><span class="str">"{greeting}, {name}!"</span>,
            <span class="str">"data_slush"</span>: {<span class="str">"greeted_user"</span>: name, <span class="str">"time_of_day"</span>: greeting}
        }</code></pre>
          </div>
        </div>

        <p>Drop the file into the agents directory. The framework auto-discovers all files matching <code>*Agent.ts</code> (TypeScript) or <code>*_agent.py</code> (Python) — no registration step required.</p>
      </div>

      <!-- Step 6: Test It -->
      <div class="step" id="step-6">
        <div class="step-number">6</div>
        <h2>Test It</h2>
        <p>After saving the file, confirm the agent is discovered and invoke it directly by name.</p>

        <pre><code><span class="comment"># Verify it was discovered</span>
<span class="cmd">openrappter --list-agents</span>
<span class="comment"># Should now include GreeterAgent in the list</span>

<span class="comment"># Invoke it directly</span>
<span class="cmd">openrappter --agent greeter "greet Alice"</span></code></pre>

        <div class="terminal">
          <div class="terminal-header">
            <span class="terminal-dot red"></span>
            <span class="terminal-dot yellow"></span>
            <span class="terminal-dot green"></span>
            <span class="terminal-title">invoking GreeterAgent</span>
          </div>
          <div class="terminal-body">
            <div class="terminal-line">
              <span class="terminal-prompt">$</span>
              <span class="terminal-command">openrappter --agent greeter "greet Alice"</span>
            </div>
            <div class="terminal-output">Executing GreeterAgent...</div>
            <div class="terminal-output">Data sloshing: injecting temporal + memory context</div>
            <div class="terminal-success">Agent response:</div>
            <div class="terminal-output">{</div>
            <div class="terminal-output">  "message": "Good afternoon, Alice!",</div>
            <div class="terminal-output">  "data_slush": {</div>
            <div class="terminal-output">    "greeted_user": "Alice",</div>
            <div class="terminal-output">    "time_of_day": "Good afternoon"</div>
            <div class="terminal-output">  }</div>
            <div class="terminal-output">}</div>
          </div>
        </div>

        <p>The greeting matches the current time of day because the <code>perform()</code> method reads the system clock. In the next step, you will see how to get this and much richer context from the data sloshing pipeline instead.</p>

        <p>You can also write a Vitest test alongside the agent (TypeScript) or a pytest file (Python) to validate behavior in CI:</p>

        <pre><code><span class="comment">// typescript/src/__tests__/GreeterAgent.test.ts</span>
<span class="kw">import</span> { describe, it, expect } <span class="kw">from</span> <span class="str">'vitest'</span>;
<span class="kw">import</span> { GreeterAgent } <span class="kw">from</span> <span class="str">'../agents/GreeterAgent.js'</span>;

describe(<span class="str">'GreeterAgent'</span>, () => {
  it(<span class="str">'returns a greeting with the provided name'</span>, <span class="kw">async</span> () => {
    <span class="kw">const</span> agent = <span class="kw">new</span> <span class="fn">GreeterAgent</span>();
    <span class="kw">const</span> result = <span class="kw">await</span> agent.<span class="fn">perform</span>({ name: <span class="str">'Alice'</span> });
    expect(result.message).<span class="fn">toContain</span>(<span class="str">'Alice'</span>);
    expect(result.data_slush.greeted_user).<span class="fn">toBe</span>(<span class="str">'Alice'</span>);
  });
});</code></pre>
      </div>

      <!-- Step 7: Data Sloshing -->
      <div class="step" id="step-7">
        <div class="step-number">7</div>
        <h2>Data Sloshing</h2>
        <p>Before <code>perform()</code> is ever called, the framework automatically gathers context signals and synthesizes an <em>orientation</em> for your agent. This is data sloshing — implicit context enrichment that happens on every execution without any work from you.</p>

        <p>The signals are accessible in <code>perform()</code> via <code>getSignal()</code> (TypeScript) or <code>get_signal()</code> (Python) using dot-notation paths:</p>

        <div class="code-tabs">
          <div class="code-tabs-header">
            <button class="code-tab-btn active" onclick="switchTab(this, 'ts-step7')">TypeScript</button>
            <button class="code-tab-btn" onclick="switchTab(this, 'py-step7')">Python</button>
          </div>
          <div class="code-tab-content active" id="ts-step7">
<pre><code><span class="kw">async</span> <span class="fn">perform</span>(kwargs: Record&lt;string, unknown&gt;) {
  <span class="comment">// Temporal awareness — injected before perform() runs</span>
  <span class="kw">const</span> timeOfDay    = <span class="kw">this</span>.<span class="fn">getSignal</span>&lt;string&gt;(<span class="str">'temporal.time_of_day'</span>, <span class="str">'morning'</span>);
  <span class="kw">const</span> isWeekend    = <span class="kw">this</span>.<span class="fn">getSignal</span>&lt;boolean&gt;(<span class="str">'temporal.is_weekend'</span>, <span class="kw">false</span>);
  <span class="kw">const</span> fiscalPeriod = <span class="kw">this</span>.<span class="fn">getSignal</span>&lt;string&gt;(<span class="str">'temporal.fiscal_period'</span>);

  <span class="comment">// Synthesized orientation — how confident is the agent?</span>
  <span class="kw">const</span> confidence = <span class="kw">this</span>.<span class="fn">getSignal</span>&lt;string&gt;(<span class="str">'orientation.confidence'</span>, <span class="str">'medium'</span>);
  <span class="kw">const</span> approach   = <span class="kw">this</span>.<span class="fn">getSignal</span>&lt;string&gt;(<span class="str">'orientation.approach'</span>);
  <span class="kw">if</span> (confidence === <span class="str">'low'</span>) {
    <span class="kw">return</span> { status: <span class="str">'clarify'</span>, message: <span class="str">'Could you be more specific?'</span> };
  }

  <span class="comment">// Query signals — understand what the user is asking</span>
  <span class="kw">const</span> isQuestion  = <span class="kw">this</span>.<span class="fn">getSignal</span>&lt;boolean&gt;(<span class="str">'query_signals.is_question'</span>, <span class="kw">false</span>);
  <span class="kw">const</span> specificity = <span class="kw">this</span>.<span class="fn">getSignal</span>&lt;string&gt;(<span class="str">'query_signals.specificity'</span>);

  <span class="comment">// Memory echoes — recent relevant memories surfaced automatically</span>
  <span class="kw">const</span> echoes = <span class="kw">this</span>.<span class="fn">getSignal</span>&lt;any[]&gt;(<span class="str">'memory_echoes'</span>, []);
  <span class="kw">if</span> (echoes.length &gt; 0) {
    <span class="kw">const</span> lastEcho = echoes[0];  <span class="comment">// most relevant past interaction</span>
  }

  <span class="comment">// Upstream slush — curated signals from the previous agent in a chain</span>
  <span class="kw">const</span> upstream = <span class="kw">this</span>.context.upstream_slush ?? {};
}</code></pre>
          </div>
          <div class="code-tab-content" id="py-step7">
<pre><code><span class="kw">def</span> <span class="fn">perform</span>(self, **kwargs):
    <span class="comment"># Temporal awareness — injected before perform() runs</span>
    time_of_day    = self.<span class="fn">get_signal</span>(<span class="str">'temporal.time_of_day'</span>, <span class="str">'morning'</span>)
    is_weekend     = self.<span class="fn">get_signal</span>(<span class="str">'temporal.is_weekend'</span>, <span class="kw">False</span>)
    fiscal_period  = self.<span class="fn">get_signal</span>(<span class="str">'temporal.fiscal_period'</span>)

    <span class="comment"># Synthesized orientation — how confident is the agent?</span>
    confidence = self.<span class="fn">get_signal</span>(<span class="str">'orientation.confidence'</span>, <span class="str">'medium'</span>)
    approach   = self.<span class="fn">get_signal</span>(<span class="str">'orientation.approach'</span>)
    <span class="kw">if</span> confidence == <span class="str">'low'</span>:
        <span class="kw">return</span> {<span class="str">"status"</span>: <span class="str">"clarify"</span>, <span class="str">"message"</span>: <span class="str">"Could you be more specific?"</span>}

    <span class="comment"># Query signals — understand what the user is asking</span>
    is_question  = self.<span class="fn">get_signal</span>(<span class="str">'query_signals.is_question'</span>, <span class="kw">False</span>)
    specificity  = self.<span class="fn">get_signal</span>(<span class="str">'query_signals.specificity'</span>)

    <span class="comment"># Memory echoes — recent relevant memories surfaced automatically</span>
    echoes = self.<span class="fn">get_signal</span>(<span class="str">'memory_echoes'</span>, [])
    <span class="kw">if</span> echoes:
        last_echo = echoes[0]  <span class="comment"># most relevant past interaction</span>

    <span class="comment"># Upstream slush — curated signals from the previous agent in a chain</span>
    upstream = self.context.<span class="fn">get</span>(<span class="str">'upstream_slush'</span>, {})</code></pre>
          </div>
        </div>

        <p>All available signal namespaces: <code>temporal.*</code>, <code>memory_echoes</code>, <code>query_signals.*</code>, <code>behavioral_hints.*</code>, <code>orientation.*</code>, and <code>upstream_slush.*</code>. See the <a href="./architecture.html">Architecture page</a> for the full signal reference.</p>

        <div class="info-box">
          <strong>Data Slush:</strong> When your agent returns a <code>data_slush</code> key in its output, the framework extracts those values and stores them in <code>lastDataSlush</code> (TypeScript) or <code>last_data_slush</code> (Python). The next agent in the chain can receive this as <code>upstream_slush</code> — enabling LLM-free, deterministic agent-to-agent pipelines.
        </div>
      </div>

      <!-- Step 8: Chain Agents -->
      <div class="step" id="step-8">
        <div class="step-number">8</div>
        <h2>Chain Agents</h2>
        <p>Agent chaining lets you build pipelines where one agent's output becomes the next agent's context. Agent A returns <code>data_slush</code> containing curated signals; Agent B receives that as <code>upstream_slush</code> via its <code>execute()</code> call.</p>

        <div class="code-tabs">
          <div class="code-tabs-header">
            <button class="code-tab-btn active" onclick="switchTab(this, 'ts-step8')">TypeScript</button>
            <button class="code-tab-btn" onclick="switchTab(this, 'py-step8')">Python</button>
          </div>
          <div class="code-tab-content active" id="ts-step8">
<pre><code><span class="kw">import</span> { GreeterAgent } <span class="kw">from</span> <span class="str">'./agents/GreeterAgent.js'</span>;
<span class="kw">import</span> { FollowUpAgent } <span class="kw">from</span> <span class="str">'./agents/FollowUpAgent.js'</span>;

<span class="comment">// Step 1: Agent A runs and populates lastDataSlush</span>
<span class="kw">const</span> greeter = <span class="kw">new</span> <span class="fn">GreeterAgent</span>();
<span class="kw">await</span> greeter.<span class="fn">execute</span>({ query: <span class="str">'greet Alice'</span>, name: <span class="str">'Alice'</span> });

<span class="comment">// greeter.lastDataSlush is now:</span>
<span class="comment">// { greeted_user: "Alice", time_of_day: "Good afternoon" }</span>

<span class="comment">// Step 2: Agent B receives A's slush as upstream context</span>
<span class="kw">const</span> followUp = <span class="kw">new</span> <span class="fn">FollowUpAgent</span>();
<span class="kw">const</span> result = <span class="kw">await</span> followUp.<span class="fn">execute</span>({
  query: <span class="str">'suggest something for Alice'</span>,
  upstream_slush: greeter.lastDataSlush   <span class="comment">// pass A's slush to B</span>
});

<span class="comment">// Inside FollowUpAgent.perform():</span>
<span class="comment">// const greetedUser = this.getSignal('upstream_slush.greeted_user');</span>
<span class="comment">// const timeOfDay   = this.getSignal('upstream_slush.time_of_day');</span></code></pre>
          </div>
          <div class="code-tab-content" id="py-step8">
<pre><code><span class="kw">from</span> openrappter.agents.greeter_agent <span class="kw">import</span> GreeterAgent
<span class="kw">from</span> openrappter.agents.follow_up_agent <span class="kw">import</span> FollowUpAgent

<span class="comment"># Step 1: Agent A runs and populates last_data_slush</span>
greeter = <span class="fn">GreeterAgent</span>()
greeter.<span class="fn">execute</span>(query=<span class="str">'greet Alice'</span>, name=<span class="str">'Alice'</span>)

<span class="comment"># greeter.last_data_slush is now:</span>
<span class="comment"># {"greeted_user": "Alice", "time_of_day": "Good afternoon"}</span>

<span class="comment"># Step 2: Agent B receives A's slush as upstream context</span>
follow_up = <span class="fn">FollowUpAgent</span>()
result = follow_up.<span class="fn">execute</span>(
    query=<span class="str">'suggest something for Alice'</span>,
    upstream_slush=greeter.last_data_slush   <span class="comment"># pass A's slush to B</span>
)

<span class="comment"># Inside FollowUpAgent.perform():</span>
<span class="comment"># greeted_user = self.get_signal('upstream_slush.greeted_user')</span>
<span class="comment"># time_of_day  = self.get_signal('upstream_slush.time_of_day')</span></code></pre>
          </div>
        </div>

        <p>This pattern is the foundation of LLM-free agent pipelines. Agent A extracts structured facts; Agent B reasons from them — no large language model required in the middle. The <code>data_slush</code> key acts as a typed handoff contract between agents.</p>

        <p>For more complex graphs — fan-out, fan-in, conditional routing — see the multi-agent patterns in the next step.</p>
      </div>

      <!-- Step 9: Multi-Agent Patterns -->
      <div class="step" id="step-9">
        <div class="step-number">9</div>
        <h2>Multi-Agent Patterns</h2>
        <p>openrappter ships three built-in orchestration primitives for coordinating multiple agents: <code>BroadcastManager</code>, <code>AgentRouter</code>, and <code>SubAgent</code>. These cover the vast majority of multi-agent topologies.</p>

        <p><strong>BroadcastManager</strong> — send a message to multiple agents simultaneously and collect results:</p>

        <div class="code-tabs">
          <div class="code-tabs-header">
            <button class="code-tab-btn active" onclick="switchTab(this, 'ts-broadcast')">TypeScript</button>
            <button class="code-tab-btn" onclick="switchTab(this, 'py-broadcast')">Python</button>
          </div>
          <div class="code-tab-content active" id="ts-broadcast">
<pre><code><span class="kw">import</span> { BroadcastManager } <span class="kw">from</span> <span class="str">'./agents/broadcast.js'</span>;
<span class="kw">import</span> { GreeterAgent } <span class="kw">from</span> <span class="str">'./agents/GreeterAgent.js'</span>;
<span class="kw">import</span> { ShellAgent } <span class="kw">from</span> <span class="str">'./agents/ShellAgent.js'</span>;

<span class="comment">// 'all' — wait for every agent to complete</span>
<span class="kw">const</span> broadcast = <span class="kw">new</span> <span class="fn">BroadcastManager</span>([<span class="kw">new</span> <span class="fn">GreeterAgent</span>(), <span class="kw">new</span> <span class="fn">ShellAgent</span>()], <span class="str">'all'</span>);
<span class="kw">const</span> results = <span class="kw">await</span> broadcast.<span class="fn">execute</span>({ query: <span class="str">'hello'</span> });

<span class="comment">// 'race' — take the first agent to respond</span>
<span class="kw">const</span> race = <span class="kw">new</span> <span class="fn">BroadcastManager</span>([agentA, agentB, agentC], <span class="str">'race'</span>);
<span class="kw">const</span> first = <span class="kw">await</span> race.<span class="fn">execute</span>({ query: <span class="str">'who can answer this fastest?'</span> });

<span class="comment">// 'fallback' — try agents in order until one succeeds</span>
<span class="kw">const</span> fallback = <span class="kw">new</span> <span class="fn">BroadcastManager</span>([primaryAgent, backupAgent], <span class="str">'fallback'</span>);
<span class="kw">const</span> safe = <span class="kw">await</span> fallback.<span class="fn">execute</span>({ query: <span class="str">'try primary, then backup'</span> });</code></pre>
          </div>
          <div class="code-tab-content" id="py-broadcast">
<pre><code><span class="comment"># Python BroadcastManager mirrors the TypeScript API</span>
<span class="kw">from</span> openrappter.agents.broadcast <span class="kw">import</span> BroadcastManager
<span class="kw">from</span> openrappter.agents.greeter_agent <span class="kw">import</span> GreeterAgent
<span class="kw">from</span> openrappter.agents.shell_agent <span class="kw">import</span> ShellAgent

<span class="comment"># 'all' — wait for every agent to complete</span>
broadcast = <span class="fn">BroadcastManager</span>([<span class="fn">GreeterAgent</span>(), <span class="fn">ShellAgent</span>()], mode=<span class="str">'all'</span>)
results = broadcast.<span class="fn">execute</span>(query=<span class="str">'hello'</span>)

<span class="comment"># 'race' — take the first agent to respond</span>
race = <span class="fn">BroadcastManager</span>([agent_a, agent_b, agent_c], mode=<span class="str">'race'</span>)
first = race.<span class="fn">execute</span>(query=<span class="str">'who can answer this fastest?'</span>)

<span class="comment"># 'fallback' — try agents in order until one succeeds</span>
fallback = <span class="fn">BroadcastManager</span>([primary_agent, backup_agent], mode=<span class="str">'fallback'</span>)
safe = fallback.<span class="fn">execute</span>(query=<span class="str">'try primary, then backup'</span>)</code></pre>
          </div>
        </div>

        <p><strong>AgentRouter</strong> — route messages to different agents based on rules (sender, channel, group, or pattern matching), with priority and session key isolation:</p>

        <pre><code><span class="kw">import</span> { AgentRouter } <span class="kw">from</span> <span class="str">'./agents/router.js'</span>;

<span class="kw">const</span> router = <span class="kw">new</span> <span class="fn">AgentRouter</span>();
router.<span class="fn">addRule</span>({ pattern: <span class="str">/^greet/i</span>, agent: <span class="kw">new</span> <span class="fn">GreeterAgent</span>(), priority: 10 });
router.<span class="fn">addRule</span>({ pattern: <span class="str">/^run|^exec/i</span>, agent: <span class="kw">new</span> <span class="fn">ShellAgent</span>(), priority: 5 });
router.<span class="fn">addRule</span>({ channel: <span class="str">'slack'</span>, agent: <span class="kw">new</span> <span class="fn">SlackAgent</span>(), priority: 1 });

<span class="kw">const</span> result = <span class="kw">await</span> router.<span class="fn">route</span>({ query: <span class="str">'greet the team'</span>, channel: <span class="str">'cli'</span> });</code></pre>

        <p><strong>SubAgent</strong> — invoke nested agents from within a parent agent's <code>perform()</code> method, with configurable depth limits and built-in loop detection to prevent infinite recursion:</p>

        <pre><code><span class="kw">import</span> { SubAgent } <span class="kw">from</span> <span class="str">'./agents/subagent.js'</span>;

<span class="comment">// Inside a parent agent's perform():</span>
<span class="kw">const</span> sub = <span class="kw">new</span> <span class="fn">SubAgent</span>(<span class="kw">new</span> <span class="fn">ShellAgent</span>(), { maxDepth: 3 });
<span class="kw">const</span> fileList = <span class="kw">await</span> sub.<span class="fn">invoke</span>({ action: <span class="str">'list'</span>, path: <span class="str">'.'</span> });</code></pre>

        <div class="info-box">
          <strong>Next:</strong> The <a href="./architecture.html">Architecture page</a> covers the full execution flow, all sloshing signal namespaces, the WebSocket gateway, multi-channel routing (Slack, Discord, Telegram, iMessage, Teams), and the ClawHub skills system in depth.
        </div>

        <!-- Next Steps -->
        <div class="info-box" style="margin-top:2rem;">
          <strong>Next Steps</strong>
          <ul style="margin-top:0.5rem;padding-left:1.25rem;">
            <li><a href="./docs.html">Full Documentation</a> — Complete reference for all systems</li>
            <li><a href="./architecture.html">Architecture Deep Dive</a> — How data sloshing and agents work</li>
            <li><a href="https://github.com/kody-w/openrappter">GitHub Repository</a> — Source code and contributing guide</li>
          </ul>
        </div>
      </div>

    </main>
  </div>

  <!-- Footer -->
  <footer>
    <div class="footer-container">
      <div class="footer-links">
        <a href="https://github.com/kody-w/openrappter">GitHub</a>
        <a href="./docs.html">Docs</a>
        <a href="./">Home</a>
        <a href="./changelog.html">Changelog</a>
      </div>
      <div class="footer-copy">MIT License</div>
    </div>
  </footer>

  <script src="./nav.js"></script>
</body>
</html>
