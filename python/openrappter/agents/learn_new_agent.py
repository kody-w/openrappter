"""
LearnNewAgent - Dynamically generates and hot-loads new agents.

This meta-agent creates new agents based on user descriptions,
writes them to the agents folder, and hot-loads them for immediate use.
"""

import json
import re
import subprocess
from pathlib import Path
from datetime import datetime

from openrappter.agents.basic_agent import BasicAgent


class LearnNewAgent(BasicAgent):
    """
    Agent that generates new agents from natural language descriptions.
    
    Capabilities:
    - Generate agent code from description
    - Write agent to agents/ directory
    - Hot-load agent for immediate use
    - List user-created agents
    """
    
    AGENT_TEMPLATE = '''"""
{description}

Auto-generated by LearnNewAgent on {date}.
"""

import json
{extra_imports}from openrappter.agents.basic_agent import BasicAgent


class {class_name}(BasicAgent):
    """
    {short_description}
    """
    
    def __init__(self):
        self.name = '{agent_name}'
        self.metadata = {{
            "name": self.name,
            "description": "{agent_description}",
            "parameters": {{
                "type": "object",
                "properties": {{
                    "query": {{
                        "type": "string",
                        "description": "The user's request or input."
                    }}{extra_params}
                }},
                "required": []
            }}
        }}
        super().__init__(name=self.name, metadata=self.metadata)
    
    def perform(self, **kwargs):
        """Execute the agent's task."""
        query = kwargs.get('query', '')
        
{perform_body}
'''
    
    def __init__(self):
        self.name = 'LearnNew'
        self.metadata = {
            "name": self.name,
            "description": "Creates new agents from natural language descriptions. Describe what you want the agent to do and it will generate, save, and hot-load it.",
            "parameters": {
                "type": "object",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Natural language description of what the new agent should do."
                    },
                    "name": {
                        "type": "string",
                        "description": "Name for the new agent (optional, will be generated from description)."
                    },
                    "action": {
                        "type": "string",
                        "description": "Action to perform.",
                        "enum": ["create", "list", "delete"]
                    },
                    "query": {
                        "type": "string",
                        "description": "Natural language query that may contain the agent description."
                    }
                },
                "required": []
            }
        }
        self.agents_dir = Path(__file__).parent
        super().__init__(name=self.name, metadata=self.metadata)
    
    def perform(self, **kwargs):
        """Generate, save, and hot-load a new agent."""
        action = kwargs.get('action', 'create')
        description = kwargs.get('description', '')
        name = kwargs.get('name', '')
        query = kwargs.get('query', '')
        
        # Use query as description if description not provided
        if not description and query:
            description = query
        
        if action == 'list':
            return self._list_generated_agents()
        elif action == 'delete':
            return self._delete_agent(name or description)
        else:
            return self._create_agent(description, name)
    
    def _create_agent(self, description: str, name: str = '') -> str:
        """Create a new agent from description."""
        if not description:
            return json.dumps({
                "status": "error",
                "message": "Please provide a description of what the agent should do."
            })
        
        # Generate agent name from description if not provided
        if not name:
            name = self._generate_name(description)
        
        # Sanitize name
        name = self._sanitize_name(name)
        class_name = f"{name}Agent"
        file_name = f"{self._to_snake_case(name)}_agent.py"
        file_path = self.agents_dir / file_name
        
        # Check if agent already exists
        if file_path.exists():
            return json.dumps({
                "status": "error",
                "message": f"Agent '{name}' already exists at {file_path}"
            })
        
        # Generate agent code using Copilot if available
        agent_code = self._generate_agent_code(description, name, class_name)
        
        # Write agent file
        try:
            file_path.write_text(agent_code)
        except Exception as e:
            return json.dumps({
                "status": "error",
                "message": f"Failed to write agent file: {e}"
            })
        
        # Hot-load the agent
        hot_load_result = self._hot_load_agent(file_path, class_name)
        
        result = {
            "status": "success",
            "message": f"Created and loaded agent '{name}'",
            "agent_name": name,
            "file_path": str(file_path),
            "hot_loaded": hot_load_result.get("success", False),
            "description": description[:200]
        }
        
        # Include dependency info if any were installed
        if hot_load_result.get("installed_deps"):
            result["installed_dependencies"] = hot_load_result["installed_deps"]
        
        # Include error info if hot-load failed
        if not hot_load_result.get("success"):
            result["hot_load_error"] = hot_load_result.get("error")
            if hot_load_result.get("hint"):
                result["hint"] = hot_load_result["hint"]
        
        return json.dumps(result)
    
    def _generate_name(self, description: str) -> str:
        """Generate agent name from description."""
        # Try Copilot first
        try:
            result = subprocess.run(
                ['copilot', '--message', f'Generate a short 1-2 word CamelCase name for an agent that: {description[:200]}. Reply with ONLY the name, nothing else.'],
                capture_output=True, text=True, timeout=10
            )
            if result.returncode == 0 and result.stdout.strip():
                name = result.stdout.strip().split('\n')[0]
                # Clean up any extra text
                name = re.sub(r'[^a-zA-Z]', '', name)
                if name and len(name) <= 30:
                    return name
        except:
            pass
        
        # Fallback: extract key words
        words = description.lower().split()
        keywords = [w for w in words if len(w) > 3 and w not in 
                   ['that', 'this', 'with', 'from', 'agent', 'create', 'make', 'want', 'should', 'would', 'could']]
        
        if keywords:
            return ''.join(w.capitalize() for w in keywords[:2])
        return 'Custom'
    
    def _sanitize_name(self, name: str) -> str:
        """Ensure name is valid for class/file naming."""
        # Remove non-alphanumeric
        name = re.sub(r'[^a-zA-Z0-9]', '', name)
        # Ensure starts with letter
        if name and not name[0].isalpha():
            name = 'Agent' + name
        # Capitalize first letter
        if name:
            name = name[0].upper() + name[1:]
        return name or 'Custom'
    
    def _to_snake_case(self, name: str) -> str:
        """Convert CamelCase to snake_case."""
        s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
        return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()
    
    def _generate_agent_code(self, description: str, name: str, class_name: str) -> str:
        """Generate agent code, using Copilot if available."""
        
        # Try to get intelligent implementation from Copilot
        perform_body = self._generate_perform_body(description)
        extra_params = self._generate_extra_params(description)
        extra_imports = self._generate_extra_imports(description)
        
        # Escape quotes in description for string literals
        safe_desc = description.replace('"', '\\"').replace('\n', ' ')
        short_desc = safe_desc[:100] + ('...' if len(safe_desc) > 100 else '')
        
        return self.AGENT_TEMPLATE.format(
            description=f"{name}Agent - {description}",
            date=datetime.now().strftime("%Y-%m-%d %H:%M"),
            class_name=class_name,
            short_description=short_desc,
            agent_name=name,
            agent_description=safe_desc[:200],
            extra_imports=extra_imports,
            extra_params=extra_params,
            perform_body=perform_body
        )
    
    def _generate_perform_body(self, description: str) -> str:
        """Generate the perform method body using Copilot."""
        try:
            prompt = f"""Generate ONLY the Python code for the body of a perform() method for an agent that: {description}

Rules:
- Return a JSON string with status and result
- Use kwargs.get() to access parameters
- Keep it simple and functional
- Do NOT include the method signature, just the body
- Indent with 8 spaces

Example format:
        # Process the query
        result = "processed: " + query
        return json.dumps({{"status": "success", "result": result}})"""
            
            result = subprocess.run(
                ['copilot', '--message', prompt],
                capture_output=True, text=True, timeout=30
            )
            
            if result.returncode == 0 and result.stdout.strip():
                body = result.stdout.strip()
                # Extract code if wrapped in markdown
                if '```python' in body:
                    body = body.split('```python')[1].split('```')[0]
                elif '```' in body:
                    body = body.split('```')[1].split('```')[0]
                
                # Ensure proper indentation (8 spaces)
                lines = body.strip().split('\n')
                indented = '\n'.join('        ' + line.lstrip() if line.strip() else '' for line in lines)
                if indented.strip():
                    return indented
        except:
            pass
        
        # Fallback: simple echo implementation
        return '''        # Default implementation - echo the query
        if not query:
            return json.dumps({
                "status": "error",
                "message": "No query provided"
            })
        
        return json.dumps({
            "status": "success",
            "query": query,
            "result": f"Processed by {self.name}: {query}"
        })'''
    
    def _generate_extra_params(self, description: str) -> str:
        """Generate extra parameters based on description."""
        extra = ""
        desc_lower = description.lower()
        
        # Add common parameters based on description keywords
        if any(w in desc_lower for w in ['file', 'read', 'write', 'path']):
            extra += ''',
                    "path": {
                        "type": "string",
                        "description": "File or directory path."
                    }'''
        
        if any(w in desc_lower for w in ['url', 'http', 'web', 'fetch']):
            extra += ''',
                    "url": {
                        "type": "string",
                        "description": "URL to access."
                    }'''
        
        if any(w in desc_lower for w in ['number', 'count', 'amount', 'limit']):
            extra += ''',
                    "count": {
                        "type": "integer",
                        "description": "Number or count value."
                    }'''
        
        return extra
    
    def _generate_extra_imports(self, description: str) -> str:
        """Generate extra imports based on description keywords."""
        imports = []
        desc_lower = description.lower()
        
        # Map keywords to imports
        import_map = {
            ('http', 'api', 'fetch', 'url', 'web', 'request'): 'import urllib.request',
            ('html', 'scrape', 'parse html', 'beautifulsoup'): 'from bs4 import BeautifulSoup',
            ('csv', 'spreadsheet'): 'import csv',
            ('xml',): 'import xml.etree.ElementTree as ET',
            ('datetime', 'date', 'time', 'timestamp'): 'from datetime import datetime',
            ('regex', 'pattern', 'match'): 'import re',
            ('file', 'read', 'write', 'path'): 'from pathlib import Path',
            ('base64', 'encode', 'decode'): 'import base64',
            ('hash', 'md5', 'sha'): 'import hashlib',
            ('random', 'shuffle', 'choice'): 'import random',
            ('sleep', 'wait', 'delay'): 'import time',
            ('environment', 'env var'): 'import os',
        }
        
        for keywords, import_stmt in import_map.items():
            if any(kw in desc_lower for kw in keywords):
                if import_stmt not in imports:
                    imports.append(import_stmt)
        
        if imports:
            return '\n'.join(imports) + '\n'
        return ''
    
    def _hot_load_agent(self, file_path: Path, class_name: str) -> dict:
        """Hot-load an agent into the running system, installing dependencies if needed."""
        try:
            import importlib.util
            
            # First, detect and install any missing dependencies
            code = file_path.read_text()
            missing_deps = self._detect_missing_imports(code)
            
            if missing_deps:
                install_result = self._install_dependencies(missing_deps)
                if not install_result['success']:
                    return {
                        "success": False, 
                        "error": f"Failed to install dependencies: {install_result['error']}",
                        "missing_deps": missing_deps
                    }
            
            # Load the module
            spec = importlib.util.spec_from_file_location(
                file_path.stem, 
                file_path
            )
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            
            # Get the agent class
            agent_class = getattr(module, class_name, None)
            if agent_class is None:
                return {"success": False, "error": "Class not found in module"}
            
            # Try to register with the orchestrator if available
            # This works by updating sys.modules so next import finds it
            import sys
            module_name = f"agents.{file_path.stem}"
            sys.modules[module_name] = module
            
            result = {"success": True, "class": class_name}
            if missing_deps:
                result["installed_deps"] = missing_deps
            return result
            
        except ModuleNotFoundError as e:
            # Extract module name from error
            missing = str(e).split("'")[1] if "'" in str(e) else str(e)
            return {
                "success": False, 
                "error": f"Missing module: {missing}",
                "hint": f"Try: pip install {missing}"
            }
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def _detect_missing_imports(self, code: str) -> list:
        """Detect imports in code that aren't available."""
        import importlib
        
        missing = []
        
        # Find all import statements
        import_pattern = r'^(?:from\s+(\w+)|import\s+(\w+))'
        for line in code.split('\n'):
            line = line.strip()
            match = re.match(import_pattern, line)
            if match:
                module_name = match.group(1) or match.group(2)
                
                # Skip standard library and local imports
                if module_name in self._stdlib_modules():
                    continue
                if module_name == 'agents':
                    continue
                
                # Try to import
                try:
                    importlib.import_module(module_name)
                except ImportError:
                    # Map common module names to pip package names
                    pkg_name = self._module_to_package(module_name)
                    if pkg_name not in missing:
                        missing.append(pkg_name)
        
        return missing
    
    def _module_to_package(self, module_name: str) -> str:
        """Map Python module names to pip package names."""
        # Common mappings where module != package name
        mappings = {
            'cv2': 'opencv-python',
            'PIL': 'Pillow',
            'sklearn': 'scikit-learn',
            'yaml': 'pyyaml',
            'bs4': 'beautifulsoup4',
            'dotenv': 'python-dotenv',
            'jwt': 'pyjwt',
            'serial': 'pyserial',
            'usb': 'pyusb',
            'Crypto': 'pycryptodome',
        }
        return mappings.get(module_name, module_name)
    
    def _stdlib_modules(self) -> set:
        """Return set of standard library module names."""
        return {
            'abc', 'argparse', 'ast', 'asyncio', 'base64', 'collections',
            'contextlib', 'copy', 'csv', 'datetime', 'decimal', 'difflib',
            'email', 'enum', 'functools', 'glob', 'gzip', 'hashlib', 'heapq',
            'html', 'http', 'importlib', 'inspect', 'io', 'itertools', 'json',
            'logging', 'math', 'mimetypes', 'multiprocessing', 'operator', 'os',
            'pathlib', 'pickle', 'platform', 'pprint', 'queue', 'random', 're',
            'shutil', 'signal', 'socket', 'sqlite3', 'ssl', 'statistics',
            'string', 'struct', 'subprocess', 'sys', 'tempfile', 'textwrap',
            'threading', 'time', 'traceback', 'types', 'typing', 'unittest',
            'urllib', 'uuid', 'warnings', 'weakref', 'xml', 'zipfile', 'zlib'
        }
    
    def _install_dependencies(self, packages: list) -> dict:
        """Install missing pip packages."""
        if not packages:
            return {"success": True}
        
        try:
            import sys
            
            for pkg in packages:
                result = subprocess.run(
                    [sys.executable, '-m', 'pip', 'install', '--quiet', pkg],
                    capture_output=True,
                    text=True,
                    timeout=60
                )
                
                if result.returncode != 0:
                    return {
                        "success": False,
                        "error": f"pip install {pkg} failed: {result.stderr}"
                    }
            
            return {"success": True, "installed": packages}
            
        except subprocess.TimeoutExpired:
            return {"success": False, "error": "pip install timed out"}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def _list_generated_agents(self) -> str:
        """List all user-generated agents."""
        agents = []
        
        for f in self.agents_dir.glob('*_agent.py'):
            if f.name in ['basic_agent.py', 'manage_memory_agent.py', 
                         'context_memory_agent.py', 'shell_agent.py',
                         'learn_new_agent.py']:
                continue
            
            # Check if auto-generated
            content = f.read_text()
            is_generated = 'Auto-generated by LearnNewAgent' in content
            
            agents.append({
                "name": f.stem.replace('_agent', ''),
                "file": f.name,
                "auto_generated": is_generated
            })
        
        return json.dumps({
            "status": "success",
            "agents": agents,
            "count": len(agents)
        })
    
    def _delete_agent(self, name: str) -> str:
        """Delete a user-generated agent."""
        if not name:
            return json.dumps({
                "status": "error",
                "message": "Please provide the agent name to delete."
            })
        
        # Find the agent file
        snake_name = self._to_snake_case(self._sanitize_name(name))
        file_path = self.agents_dir / f"{snake_name}_agent.py"
        
        if not file_path.exists():
            # Try without transformation
            for f in self.agents_dir.glob('*_agent.py'):
                if name.lower() in f.name.lower():
                    file_path = f
                    break
        
        if not file_path.exists():
            return json.dumps({
                "status": "error",
                "message": f"Agent '{name}' not found."
            })
        
        # Prevent deleting core agents
        core_agents = ['basic_agent.py', 'manage_memory_agent.py', 
                      'context_memory_agent.py', 'shell_agent.py',
                      'learn_new_agent.py']
        if file_path.name in core_agents:
            return json.dumps({
                "status": "error",
                "message": "Cannot delete core agents."
            })
        
        try:
            file_path.unlink()
            return json.dumps({
                "status": "success",
                "message": f"Deleted agent '{name}'",
                "file": str(file_path)
            })
        except Exception as e:
            return json.dumps({
                "status": "error",
                "message": str(e)
            })
