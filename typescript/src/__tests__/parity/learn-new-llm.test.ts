/**
 * LearnNewAgent LLM Integration Tests
 *
 * Tests the LLM-powered code generation path in LearnNewAgent.
 * Uses a mock LLMProvider to verify the integration without real API calls.
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import fs from 'fs/promises';
import path from 'path';
import os from 'os';
import type { LLMProvider, Message, ProviderResponse, ChatOptions } from '../../providers/types.js';

// ── Mock LLM Provider ────────────────────────────────────────────

class MockLLMProvider implements LLMProvider {
  id = 'mock';
  name = 'Mock Provider';
  callCount = 0;
  lastMessages: Message[] = [];
  response: string | null = null;

  async chat(messages: Message[], _options?: ChatOptions): Promise<ProviderResponse> {
    this.callCount++;
    this.lastMessages = messages;
    return { content: this.response, tool_calls: null };
  }

  async isAvailable(): Promise<boolean> {
    return true;
  }

  /** Set the code the mock will return */
  setResponse(code: string): void {
    this.response = code;
  }
}

function validAgentCode(name: string, className: string): string {
  return `/**
 * Auto-generated by LearnNewAgent
 */
export function createAgent(BasicAgent) {
  class ${className} extends BasicAgent {
    constructor() {
      super('${name}', {
        name: '${name}',
        description: 'LLM-generated agent',
        parameters: { type: 'object', properties: { query: { type: 'string', description: 'Input' } }, required: [] }
      });
    }
    async perform(kwargs) {
      const query = kwargs.query || '';
      return JSON.stringify({ status: 'success', result: 'LLM generated: ' + query });
    }
  }
  return ${className};
}`;
}

describe('LearnNewAgent LLM Integration', () => {
  let LearnNewAgentClass: typeof import('../../agents/LearnNewAgent.js').LearnNewAgent;
  let tmpDir: string;
  let mockProvider: MockLLMProvider;

  beforeEach(async () => {
    const mod = await import('../../agents/LearnNewAgent.js');
    LearnNewAgentClass = mod.LearnNewAgent;
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'learn-new-llm-test-'));
    mockProvider = new MockLLMProvider();
  });

  afterEach(async () => {
    try {
      await fs.rm(tmpDir, { recursive: true, force: true });
    } catch {
      // Ignore
    }
  });

  // ── Provider Wiring ────────────────────────────────────────────

  describe('Provider Wiring', () => {
    it('should accept LLMProvider in constructor', () => {
      const agent = new LearnNewAgentClass(tmpDir, mockProvider);
      expect(agent).toBeDefined();
      expect(agent.name).toBe('LearnNew');
    });

    it('should work without a provider (backward compatible)', async () => {
      const agent = new LearnNewAgentClass(tmpDir);
      const result = await agent.perform({
        action: 'create',
        description: 'test backward compat',
        name: 'BackCompat',
      });
      const parsed = JSON.parse(result);
      expect(parsed.status).toBe('success');
    });
  });

  // ── LLM Code Generation ───────────────────────────────────────

  describe('LLM Code Generation', () => {
    it('should use LLM to generate agent code when provider is available', async () => {
      mockProvider.setResponse(validAgentCode('LlmTest', 'LlmTestAgent'));

      const agent = new LearnNewAgentClass(tmpDir, mockProvider);
      const result = await agent.perform({
        action: 'create',
        description: 'test LLM generation',
        name: 'LlmTest',
      });
      const parsed = JSON.parse(result);

      expect(parsed.status).toBe('success');
      expect(parsed.hot_loaded).toBe(true);
      expect(mockProvider.callCount).toBe(1);

      // Verify the LLM-generated code was written
      const filePath = path.join(tmpDir, 'llm_test_agent.js');
      const content = await fs.readFile(filePath, 'utf-8');
      expect(content).toContain('LLM-generated agent');
    });

    it('should pass description to LLM prompt', async () => {
      mockProvider.setResponse(validAgentCode('Desc', 'DescAgent'));

      const agent = new LearnNewAgentClass(tmpDir, mockProvider);
      await agent.perform({
        action: 'create',
        description: 'analyze sentiment of text',
        name: 'Desc',
      });

      expect(mockProvider.lastMessages.length).toBe(1);
      expect(mockProvider.lastMessages[0].content).toContain('analyze sentiment of text');
    });

    it('should hot-load the LLM-generated agent', async () => {
      mockProvider.setResponse(validAgentCode('Hotload', 'HotloadAgent'));

      const agent = new LearnNewAgentClass(tmpDir, mockProvider);
      await agent.perform({
        action: 'create',
        description: 'test hot loading',
        name: 'Hotload',
      });

      const loaded = agent.getLoadedAgents().get('Hotload');
      expect(loaded).toBeDefined();
      expect(loaded!.name).toBe('Hotload');

      // Execute the generated agent
      const execResult = await loaded!.perform({ query: 'hello' });
      const parsed = JSON.parse(execResult);
      expect(parsed.status).toBe('success');
      expect(parsed.result).toContain('LLM generated');
    });
  });

  // ── Fallback to Templates ─────────────────────────────────────

  describe('Fallback to Templates', () => {
    it('should fall back to template when LLM returns null', async () => {
      mockProvider.setResponse(null as unknown as string);

      const agent = new LearnNewAgentClass(tmpDir, mockProvider);
      const result = await agent.perform({
        action: 'create',
        description: 'test fallback',
        name: 'Fallback',
      });
      const parsed = JSON.parse(result);

      expect(parsed.status).toBe('success');
      // Template code is used instead
      const filePath = path.join(tmpDir, 'fallback_agent.js');
      const content = await fs.readFile(filePath, 'utf-8');
      expect(content).toContain('Auto-generated by LearnNewAgent');
    });

    it('should fall back when LLM returns invalid code (missing createAgent)', async () => {
      mockProvider.setResponse('console.log("not an agent");');

      const agent = new LearnNewAgentClass(tmpDir, mockProvider);
      const result = await agent.perform({
        action: 'create',
        description: 'test invalid response',
        name: 'Invalid',
      });
      const parsed = JSON.parse(result);

      expect(parsed.status).toBe('success');
      const filePath = path.join(tmpDir, 'invalid_agent.js');
      const content = await fs.readFile(filePath, 'utf-8');
      // Should have fallen back to template
      expect(content).toContain('createAgent');
    });

    it('should fall back when provider throws', async () => {
      const throwingProvider: LLMProvider = {
        id: 'throw',
        name: 'Throw',
        async chat() { throw new Error('API down'); },
        async isAvailable() { return false; },
      };

      const agent = new LearnNewAgentClass(tmpDir, throwingProvider);
      const result = await agent.perform({
        action: 'create',
        description: 'test provider error',
        name: 'ProvErr',
      });
      const parsed = JSON.parse(result);
      expect(parsed.status).toBe('success');
    });

    it('should strip markdown fences from LLM response', async () => {
      const codeWithFences = '```javascript\n' + validAgentCode('Fenced', 'FencedAgent') + '\n```';
      mockProvider.setResponse(codeWithFences);

      const agent = new LearnNewAgentClass(tmpDir, mockProvider);
      const result = await agent.perform({
        action: 'create',
        description: 'test markdown stripping',
        name: 'Fenced',
      });
      const parsed = JSON.parse(result);

      expect(parsed.status).toBe('success');
      expect(parsed.hot_loaded).toBe(true);
    });
  });

  // ── Accessor ───────────────────────────────────────────────────

  describe('getLoadedAgents', () => {
    it('should expose loaded agents map', async () => {
      const agent = new LearnNewAgentClass(tmpDir);
      expect(agent.getLoadedAgents()).toBeInstanceOf(Map);
      expect(agent.getLoadedAgents().size).toBe(0);

      await agent.perform({
        action: 'create',
        description: 'test accessor',
        name: 'Accessor',
      });

      expect(agent.getLoadedAgents().size).toBe(1);
    });
  });
});
